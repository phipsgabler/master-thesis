\chapter{Implementation of Dynamic Graph Tracking in Julia}
\label{cha:impl-dynam-graph}

It has been described above that there is a trade-off between source-transformation methods and
library-based (operator overloading) approaches for tracking computation graphs.  Since the ultimate
goal of this work was to analyze dynamic probabilistic models written in \turingjl{}, properties of
both were derired.  Operator overloading has been considered as well, since it would have allowed to
potentially reuse AD implementations, but was thought insufficient, because the structure of control
flow and recursion are lost.  Inspired the the work of \textcite{innes2018don}, it seemed most
promising to start from a source-transformation based approach implemented over the intermediate
representation, especially from a usability point of view.  The advantages of using a transformation
of the IR over the surface AST are the same: there is less overhead from handling multiple syntactic
forms, and naming is already referentially transparent.  Additionally, there are existing Julia
packages to simplify handling the IR data structures and set up the transformations.

However, the dynamicity of the trace structure of general probabilistic programs needs to be
preserved and exposed to the user, for each function evaluation~-- which is different from the AD
usage, where the adjoint function is already the ultimate goal, and does not change with the
arguments.  Hence, a method for a hybrid version was developed: through an IR transformation, the
original code of a function to be tracked should be exteded by additional statements to record a
trace of the executed statements and control flow operations at runtime.  The algorithm and data
structure on which this approach is based have already been shortly described in
\textcite{gabler2019graph}, and will be more extensively explained below.  An open source
implementation is available
online\footnote{\protect\url{https://github.com/TuringLang/IRTracker.jl}}.

As we have seen above, in section~\ref{sec:comp-metapr-julia}, generated functions allow the
inspection and transformation of the intermediate representation passed-in functions.  This
technique can be applied to recursively traverse the implementation of a given function, annotating
each operation with necessay tracking statements, and changing the inputs and outputs accordingly to
extract this information from outside.  To ensure sufficient generality, we requite the following
properties of the tracking system:
\begin{enumerate}
  \firmlist
\item Storage of all intermediate values during execution.
\item Symbolic capture expressions and branches in an analyzable, graphical form.
\item Preservation of the relation of each part of the structure to the corresponding original IR.
\item Proper nesting of this information for nested function calls, making relations between
  arguments and function inputs recoverable.
\item Correct handling of constants and primitive functions in the IR.
\item Extensibility of the tracking functions, to allow multiple possible ways to analyze code
  (e.g., by different definitions of what should be recorded).
\item A way to add custom metadata to the recorded structure during tracking.
\end{enumerate}
This kind of operation will be similar to the (explicit) construction of Wengert lists in
backwards-mode AD (see section~\ref{sec:cg-ad}); but contrary to there, the nested call structure
and control flow shall be preserved as well.  Hence, we call this structure \emph{extended Wengert
  list}.  

\section{Extended Wengert Lists}
\label{sec:exteded-wengert-lists}

The extended Wengert list structure is implemented in Julia through nested objects of an abstract
supertype \jlinl{AbstractNode}, with several concrete subtypes for the different kinds of nodes.
Additionally, there are special types for the tape- and block references, and an expression type
\jlinl{TapeExpression}, mimicking the built-in \jlinl{Expr}, but adding more semantic distinctions
(such as between references and constants, and between primitive and non-primitive function calls).
On top of this, an API to query the graph structure is provided, allowing, for example, to find all
children or parents of a tape refererence up to a certain depth, or extract data from nodes, such as
referenced variables, arguments, or metadata.

\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{figures/extended-wengert-list}
  \caption{Extended Wengert list for one run of the stochastic function geom (only three levels
    shown). The central box is the tracked graph of the call \protect\jlinl{geom(1, 0.6)}. The other
    boxes show the original IR of the called non-primitive functions, to which the nodes are
    linked.  Angle brackets indictate constant values.}
  \label{fig:ext-wengert-list}
\end{figure}

Figure~\ref{fig:ext-wengert-list} illustrates the resulting extended Wengert list for one run of a
short stochastic function:
\begin{lstlisting}
geom(n, beta) = rand() < beta ? n : geom(n + 1, beta)
\end{lstlisting}
(for readability, the result is displayed to only three levels of nesting).  The function draws a
sample from the geometric distribution with parameter \jlinl{beta}, starting to count at value
\jlinl{n}. On the left, we have its IR in textual form, consisting of two blocks. The central part
is the graph of nested nodes.  There, values and jumps from the top-level call are recorded in their
encountered order, as nodes with \enquote{tape references} \jlinl{@1} to \jlinl{@9}. SSA variables
(\jlinl{\%i}) occurring in expressions of SSA definitions are also replaced in the nodes by the
respective tape references.  Each node is linked to the original IR statement it records, as
indicated by the red arrows.

In the lower middle part, we see the node corresponding to the statement \jlinl{\%7 = geom(\%6,
  \%3)}.  It is recorded at reference \jlinl{@8} with expression \jlinl{geom(@7, @3)} and value
\jlinl{4} (the notation \jlinl{⟨geom⟩(@7, @3, ()...)} indicates that \jlinl{geom} is a constant, and
no variadic arguments are passed). The values of the arguments of this call can be inspected by
looking up the respective references.  Since \jlinl{geom} is not a primitive function, the node
holds tape of child nodes as well.  In this case, it is equivalent to the top level, due to the
recursivity of \jlinl{geom}. We can see the three arguments \jlinl{@1}, \jlinl{@2}, and \jlinl{@3},
corresponding to the block arguments \jlinl{\%1}, \jlinl{\%2}, and \jlinl{\%3}, with the value of
\jlinl{@2} being now \jlinl{2} instead of \jlinl{1}.  Further we can see function calls of
\jlinl{rand} and \jlinl{<} as well as a conditional jump, corresponding to the branch the original
IR, followed by calls of \jlinl{+} and \jlinl{geom}. Following back the tape references from the
result value \jlinl{@9}, the data path of the trace can be extracted.  It can be used for
reverse-mode AD, and only these nodes would be recorded in a conventional Wengert list.  In our
system, however, we also record the nodes on the control path, consisting of \jlinl{@6} and the
nodes it depends on.


\section{Automatic Graph Tracking}
\label{sec:autom-graph-track}

Recording an extended Wengert list requires to capture all block arguments, SSA definitions, and
taken branches, with their actual values and metadata. This is achieved by extending the IR with new
statements creating nodes and recording them on the extended Wengert list structure described in the
previous section. Care needs to be taken to properly record function calls, since we need to ensure
that non-primitive functions are recursively tracked.

\begin{lstfloat}[p]
  \hrule
  \includegraphics[width=\textwidth]{figures/translation}
  \hrule
  \caption{Tracked IR of the method \protect\jlinl{geom(::Int, ::Float64)}.  Corresponding parts in
    original and transformed IR are highlighted in matching colors.  (The original IR consists of
    two blocks, shown separately on the right.)\label{lst:geom-tracked}}
\end{lstfloat}
\todo{make sure the figure in on same spread as explanation}

The transformed code of the example function geom, whose IR is displayed in
figure~\ref{fig:ext-wengert-list} above, is displayed in listing~\ref{lst:geom-tracked}.  First, a
\enquote{graph recorder} object is passed into the function via the extra argument \jlinl{\%5}.  In
this, the original IR is stored for later access.  Subsequently, every original SSA statement is
replaced by a call to one of the \protect\jlinl{trackedX} functions, to which both the function and
its arguments, wrapped into \jlinl{TapeExpression}s directly (for constants) or indirectly (through
\jlinl{trackedvariable} and \jlinl{trackedargument}, which preserve the symbolic mapping to SSA
variables).  The \jlinl{record!}  function takes care of constructing the child node of the possibly
nested call, and storing them on the recorder object.

Branches, tracked with \jlinl{trackejump} and \jlinl{trackedreturn}, cannot be stored on the
recorder object before the respective jumps are taken.  The solution is to first construct the
respective nodes of all possible branches of a block, and adding them as an extra argument to the
branches.  Then, in each target branch, the jump node from which the branch originated is
recorded immediately.  As a special case, all return branches are converted to unconditional jumps
to one new block at the end, which contains a single unified return statement.  This way, they can
be treated in the same way as other branches.

The extension of the IR is implemented as a transformation through a generated function, using the
\juliapackage{IRTools.jl} package, as described in section~\ref{sec:comp-metapr-julia}.  An exact
specification of the algorithm in pseudo-code is given in algorithm~\ref{alg:ir-transform}.  The
resulting IR consists of about three to five times as many statements as the original.  The basic
blocks and control structure are preserved, except for the redirection of return statements to the
one block at the end.  Due to JIT compilation, the transformation is performed at most a constant
number of times per method, and then stored as compiled code.  However, the tracking~-- the
recording of all statements in the extended Wengert list structure~-- happens at every execution
during runtime.  Furthermore, the extended code is available to all standard optimizations performed
in the following passes of type inference and lowering.

\todo{describe statement tracking}
\todo{describe context system}

\begin{algorithm}[p]
  \footnotesize
  % fix https://github.com/wg030/jlcode/issues/28
  \settowidth{\jlinlem}{\jlinlfont{m}}
  \hrule
  \smallskip
  \begin{algorithmic}
    \State Initialize empty IR object \jlinl{new_ir}
    \Statex
    %
    \For{\jlinl{old_block} in the original IR}
    \State Add an empty block \jlinl{new_block} to \jlinl{new_ir}
    % 
    \If{this is the first block}
    \State Add set up for \jlinl{\%recorder}
    \EndIf
    %
    \Statex
    \State Copy all arguments from \jlinl{old_block} to \jlinl{new_block}
    \State Add tracking and recording for each argument
    %
    \Statex
    \If{there exist branches to \jlinl{old_block}}
    \State Add new argument \jlinl{\%branch_node} to \jlinl{new_block}
    \State Add recording for \jlinl{\%branch_node}
    \EndIf
    %
    \Statex
    \LineComment{Transform all statements}
    \For{\jlinl{stmt} in \jlinl{statements(old_block)}}
    \State Add tracking and recording for \jlinl{stmt} to \jlinl{new_block}
    \EndFor
    %
    \Statex
    \LineComment{Transform all branches}
    \For{\jlinl{branch} in \jlinl{branches(old_block)}}
    \If{\jlinl{branch} is a return branch}
    \State Add tracking for a return node corresponding to \jlinl{branch}
    \State Add a branch replacing the original return
    \State Pass the original return value and the return node as branch arguments
    \Else
    \State Add tracking statement for a branch node corresponding to \jlinl{branch}
    \State Copy the original \jlinl{branch}
    \State Pass the branch node as extra argument to the branch
    \EndIf
    \EndFor
    %
    \EndFor
    %
    \Statex
    \LineComment{Set up return block}
    \State Add new block to \jlinl{new_ir}, with  arguments \jlinl{\%return_value} and \jlinl{\%return_node}
    \State Add recording of \jlinl{\%return_node}
    \State Add return branch, returning \jlinl{\%return_value} and \jlinl{\%recorder}
  \end{algorithmic}
  \smallskip
  \hrule
  \caption{Overview of the IR transformation to record an extended Wengert list.  This
    transformation happens inside a generated function called by \protect\jlinl{trackcall}, which
    assembles the resulting value and IR into a new node with the correct metadata.  The details of
    statement tracking and branch transformation are explained in the text; the description of
    metadata recording, and the mechanisms to correctly rename SSA variables during the
    transformation and tape references at runtime were left out for
    simplicity.\label{alg:ir-transform}}
\end{algorithm}

\section{Evaluation}
\label{sec:irtracker-eval}

Potential use cases: debugging, AD, message passing, conjugacy detection, Rao-Blackwellization.

%%% Local Variables: 
%%% TeX-master: "main"
%%% End: